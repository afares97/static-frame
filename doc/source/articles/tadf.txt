


# article

Typing DataFrames with Generics and TypeVarTuple

Better DataFrame Typing with Generics and TypeVarTuple

Better DataFrame Typing (and Runtime Validation) with Composite Generics and TypeVarTuple

Better DataFrame Typing with Composite Generics and TypeVarTuple




# presentation

Typing Arrays and DataFrames

Using Generics and TypeVarTuple for Better Typing of Arrays and DataFrames

.. Using `TypeVarTuple`
.. for Variadic Columnar dtype Specfication

Using Nested Generics and TypeVarTuple for Better Typing of Arrays and DataFrames






Use `generic` insteead of `dtype[generic]` provides a more concise representation.



### first internal presentation

A goal of StaticFrame is to provide an explicit interface that supports creating maintainable libraries using DataFrames. As Python standard library tools for typing have evolved, using type hints to make DataFrame interfaces explicit and statically checkable is now (nearly!) possible.

NumPy has made substantial effort to implement typing for n-dimensional arrays. The challenge of typing n-dimensional arrays is different than for DataFrames: while an array instance might be of any dimensionality and shape while having a single dtype, a DataFrame has indices on the rows and columns, is always two-dimensional, and has zero or more columnar dtypes.

Specifying shape for n-dimensional arrays is complex; there are numerous proposals for such a specification. DataFrames do not need the complexity of an n-dimensional shape type. As DataFrames are always two-dimensional, and columnar types bear the greatest relevance for interfaces, we can forgo full shape types and instead focus on columnar types.

PEP 646 introduces `TypeVarTuple`, a new construct (included in Python 3.11) that supports variadic generics. With the `TypeVarTuple`, the columnar types of a DataFrame can be specified as all float, four columns of Booleans, or any other defined mixture. Combined with generic specifications for index type, column type, and variadic columnar types, DataFrames can be statically typed to meet the needs of most interfaces.

In CR today we will review NumPy's approach to typing, including the as-of-yet undefined generic shape type and the heavy use of overrides to permit type-specific return values where possible. Next, I will introduce `TypeVarTuple` and the benefits of variadic generics. Then, we will see how multiple inheritance with `Generic` can be used to make `Index`, `IndexHierarchy`, `Series`, and `Frame` generic, and how, with `TypeVarTuple`, we can make columnar type specification variadic for `IndexHierarchy` and `Frame`. Finally, we will consider other `Frame` characteristics that might be combined with type hints to perform comprehensive run-time validations.



### second internal presentation

Since the advent of type hints in Python 3.5, statically typing a DataFrame was moostly limited to the type of the container:

def process(f: DataFrame) -> Series: ...

This is insufficient for a number of reason. First, DataFrames have typed index and column labels, even hierarchical indices, on either axis. Second, DataFrames have data stored in types by column. While using generics can support some of these component definitions, the variable number of types needed to define hierarchical indicies or columnar data types has not been easy to reprent. TypeVarTuple, introduced in Python 3.11, provides the missing tool to flexibly define types of hierarchical indicies or columnar data types.

def process(f: Frame[
        IndexHierarchy[IndexDate, Index[np.int64]],
        Index[np.str_],
        np.float64,
        np.float64,
        ]) -> Series[IndexDate, np.float64]: ...

Using nested generics and the new TypeVarTuple, StaticFrame 2.0 will permit full static-typing of DataFrames, including statically typing the index, columns, and columnar types. In addition to this support for static-analysis checks with mypy or Pyright, a built-in decorator permits using the same type-hints for run-time validation. Extended with one or more validators enclosed in an Annotated generic, additional run-time validation of shape, labels, or arbitrary functional checks can be included in single definition.

def process(f: Frame[
        IndexHierarchy[IndexDate, Index[np.int64]],
        Index[np.str_],
        np.float64,
        np.float64,
        ]) -> Series[IndexDate, np.float64]: ...




NumPy Typing Utilities
https://numpy.org/doc/stable/reference/typing.html

NumPy's pyi file
https://github.com/numpy/numpy/blob/main/numpy/__init__.pyi

Overloads
https://github.com/numpy/numpy/blob/18d89cc7c5b4ee202fcc6093a388e816115c1d8d/numpy/__init__.pyi#L1814

Shape types:
https://github.com/numpy/numpy/issues/16544#issuecomment-1037835285


A long discussion
https://taoa.io/posts/Shape-typing-numpy-with-pyright-and-variadic-generics

Variadic generics
https://peps.python.org/pep-0646/

Spark's use of slices to define label / dtype pairs:
https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/typehints.html



NumPy discussion on ordering of generic args:
https://github.com/numpy/numpy/issues/16547


