


# article

Type-Hinting DataFrames for Static Analysis and Runtime Validation


Generic DataFrame Type Hints for Static Analysis and Runtime Validation
Complete DataFrame Type Hints for Static Analysis and Runtime Validation



Since the advent of type hints in Python 3.5, statically typing a DataFrame has generally been limited to specifying just the type:

    def process(f: DataFrame) -> Series: ...

This is insufficient, as it ignores the types contained within the container. A DataFrame might have an integer index, string column labels, and two floating-point data columns: these characteristics define the type. A type hint is more explicit and narrowly verifiable if it specifies such type detail.



## The Missing Link

Python's built-in generic types, like ``tuple`` and ``dict``, require specification of component types to make static analysis of such components useful. While the same is true for DataFrames, there have been few attempts at comprehensively typing DataFrames.

Pandas, even with the `pandas-stubs` package, does not permit specifying the types of a DataFrame's components. The Pandas DataFrame, permitting extensive in-place mutation, may not be sensible to statically type. Fortunately, immutable DataFrames are available in StaticFrame.

Beyond mutability, Python's generic syntax has limited fully typing DataFrames. A key aspect of a DataFrame is that it has a variable number of columns of heterogenous types. Typing such a structure became much easier with the standard library's ``TypeVarTuple``, introduced in Python 3.11

A ``TypeVarTuple`` provides the missing tool to define variable numbers of types. (See PEP 646 https://peps.python.org/pep-0646). StaticFrame can then define a generic ``Frame`` with a ``TypeVar`` for the index, a ``TypeVar`` for the columns, and a ``TypeVarTuple`` for zero or more columnar types. A generic ``Series`` can be defined as a ``TypeVar`` for the index and a ``TypeVar`` for the values. StaticFrame ``Index`` and ``IndexHierarchy`` are also generic, the latter taking advantage of ``TypeVarTuple`` for defining variable numbers of per depth ``Index``.

For defining columnar types of a ``Frame`` or the values of a ``Series`` or ``Index``, NumPy generic types are uses. For example, ``np.int_`` can be used to type a platform-default integer size, while ``np.int64`` can be used to type an explicit, 64-bit integer.


## Interfaces Defined with DataFrame Generics

Using generic specifications, the same interface from above can be annotated to show a ``Frame`` with three columns being transformed into a dictionary of ``Series``.

def process(f: Frame[
        Any,
        Index[np.str_],
        np.int_,
        np.str_,
        np.float64,
        ]) -> dict[int, Series[IndexYearMonth, np.float64]]: ...


The type hints in this interface offer so much more information we might intuit what the function does. This function processes a signal table from an Open Source Asset Pricing (https://www.openassetpricing.com) dataset ("Firm Level Characteristics / Full Sets / Predictors / PredictorsIndiv"). The table has three columns: security identifier ("permno"), year and month ("yyyymm"), and signal name.

The function ignores the index (typed as ``Any``) and creates groups defined by the first column "permno" ``np.int_``. For each group, a ``Series`` is returned of the ``np.float64`` values, the index an ``IndexYearMonth`` created from the ``np.str_`` "yyyymm" column.

Rather than returning a ``dict``, the function might be revised to return a ``Series`` with a hierarchical index. The ``IndexHierarchy`` generic specifies a component ``Index`` for each depth level:

def process(f: Frame[
        Any,
        Index[np.str_],
        np.int_,
        np.str_,
        np.float64,
        ]) -> Series[IndexHierarchy[Index[np.int_], IndexYearMonth], np.float64]: ...


Combined with a better function name (e.g., ``partition_by_permno``), such rich type-hints provide an interface that makes the functionality explicit.

Even better, these type hints can be used for static analysis with Pyright (now) and MyPy (pending full ``TypeVarTuple`` support). Calling such a function with a ``Frame`` of two columns of ``np.float64``, for example, will fail a static analysis type check or deliver a warning in your editor.

## Runtime Validation


Static type checking might not be enough: runtime evaluation provides even stronger constraints. StaticFrame 2 introduces a built-in decorator, ``CallGuard.check``, that uses the same type hints for runtime validation. Extended with one or more validators enclosed in an `Annotated` generic, additional run-time validation of shape, labels, or arbitrary functional checks can be included.






Signals in: Firm Level Characteristics/Full Sets/Predictors/PredictorsIndiv

Mom12m.csv: permno	yyyymm	Mom12m
LRreversal.csv: permno	yyyymm	LRreversal
MRreversal.csv: permno	yyyymm	MRreversal



In this case, we are taking a ``Frame`` of three columns, from a table inc


@check_interface
def process(f: Frame[
        IndexHierarchy[IndexDate, Index[np.int64]],
        Annotated[Index[np.str_], Labels(('height', 'frequency))],
        Annotated[np.float64, Validator(lambda s: (s > 0).all())],
        np.float64,
        ]) -> Series[IndexDate, np.float64]: ...







==
The number of combinations of the types of these components, even with just a few columns, is astronomical.


The Pandera library permits specifying columnar schema that can be used as a type-hint stand-in for the Pandas DataFrame type.



==



Price signals: Mom12m.csv, STreversal, LRreversal.csv MRreversal.csv
Valuations: CF, EP
Risk: IdioRisk, betaVIX (edited)










# presentation

Typing DataFrames with Generics and TypeVarTuple

Better DataFrame Typing with Generics and TypeVarTuple

Better DataFrame Typing (and Runtime Validation) with Composite Generics and TypeVarTuple

Better DataFrame Typing with Composite Generics and TypeVarTuple

Typing Arrays and DataFrames

Using Generics and TypeVarTuple for Better Typing of Arrays and DataFrames

.. Using `TypeVarTuple`
.. for Variadic Columnar dtype Specfication

Using Nested Generics and TypeVarTuple for Better Typing of Arrays and DataFrames


Use `generic` insteead of `dtype[generic]` provides a more concise representation.




### first internal presentation

A goal of StaticFrame is to provide an explicit interface that supports creating maintainable libraries using DataFrames. As Python standard library tools for typing have evolved, using type hints to make DataFrame interfaces explicit and statically checkable is now (nearly!) possible.

NumPy has made substantial effort to implement typing for n-dimensional arrays. The challenge of typing n-dimensional arrays is different than for DataFrames: while an array instance might be of any dimensionality and shape while having a single dtype, a DataFrame has indices on the rows and columns, is always two-dimensional, and has zero or more columnar dtypes.

Specifying shape for n-dimensional arrays is complex; there are numerous proposals for such a specification. DataFrames do not need the complexity of an n-dimensional shape type. As DataFrames are always two-dimensional, and columnar types bear the greatest relevance for interfaces, we can forgo full shape types and instead focus on columnar types.

PEP 646 introduces `TypeVarTuple`, a new construct (included in Python 3.11) that supports variadic generics. With the `TypeVarTuple`, the columnar types of a DataFrame can be specified as all float, four columns of Booleans, or any other defined mixture. Combined with generic specifications for index type, column type, and variadic columnar types, DataFrames can be statically typed to meet the needs of most interfaces.

In CR today we will review NumPy's approach to typing, including the as-of-yet undefined generic shape type and the heavy use of overrides to permit type-specific return values where possible. Next, I will introduce `TypeVarTuple` and the benefits of variadic generics. Then, we will see how multiple inheritance with `Generic` can be used to make `Index`, `IndexHierarchy`, `Series`, and `Frame` generic, and how, with `TypeVarTuple`, we can make columnar type specification variadic for `IndexHierarchy` and `Frame`. Finally, we will consider other `Frame` characteristics that might be combined with type hints to perform comprehensive run-time validations.







NumPy Typing Utilities
https://numpy.org/doc/stable/reference/typing.html

NumPy's pyi file
https://github.com/numpy/numpy/blob/main/numpy/__init__.pyi

Overloads
https://github.com/numpy/numpy/blob/18d89cc7c5b4ee202fcc6093a388e816115c1d8d/numpy/__init__.pyi#L1814

Shape types:
https://github.com/numpy/numpy/issues/16544#issuecomment-1037835285


A long discussion
https://taoa.io/posts/Shape-typing-numpy-with-pyright-and-variadic-generics

Variadic generics
https://peps.python.org/pep-0646/

Spark's use of slices to define label / dtype pairs:
https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/typehints.html



NumPy discussion on ordering of generic args:
https://github.com/numpy/numpy/issues/16547


# some examples
# https://www.kaggle.com/datasets/paultimothymooney/stock-market-data/


# pretty good but many column, including one with tuple
# https://www.kaggle.com/datasets/sujaykapadnis/meteorites-dataset

# buoy data
# also many columns
# https://www.ndbc.noaa.gov/download_data.php?filename=4625382023.txt.gz&dir=data/stdmet/Aug/



# https://www.kaggle.com/datasets/borismarjanovic/price-volume-data-for-all-us-stocks-etfs


# three column data sets here
https://www.openassetpricing.com/


