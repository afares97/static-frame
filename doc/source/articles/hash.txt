

Improving the Performance of Python DataFrame Operations with Memoization: Hashing DataFrames in Dictionaries and Creating Message Digests

Hashing DataFrames for Usage in Dictionaries, Memoization, and Caching

Memoizing DataFrame Operations: Hashing DataFrames in Dictionaries and Creating Caches


--

A well-known technique for improving the run-time performance of a software system (in Python or any language) is function memoization. Memoization is a type of caching applied to a single function. If a function is being called multiple times with the same arguments, we can avoid repeating the calculation by storing the results in a mapping (or on disk), keyed (or named) by the arguments: upon subsequent calls, we can look for the arguments in the mapping and, if found, avoid repeating the computation by simply returning the result of the stored computation.

This opportunity does not come without tradeoffs. Memoization reduces time at the cost of space: we have to store previously calculated results either in memory or on disk. Additionally, the function memoized must be pure: the output must be determined exclusively by its inputs. Finally, there are restrictions on the types of function arguments. For in-memory memoization, those arguments must be hashable: in order to key results by arguments in a mapping, those arguments need to hashable. For disk-based memoization, arguments must be reducible to a unique string: here a cryptographic hash message digest often provides the best results.

Another challenge of memoization is cache invalidation: to avoid excessive cache growth, caches can be dropped. The Python standard library provides an excellent in-memory solution with the ``functools.lru_cache()`` decorator. This decorator implements memoization with a "least recently used" cache invalidation strategy: after reaching a maximum count, caches that have least recently been used are first to be dropped.

For Python programmers using Pandas DataFrames as function arguments, there are further challenges. As mutable containers, Pandas ``DataFrame`` and ``Series`` are not hashable. The `functools.lru_cache()` will fail if an argument is a Pandas DataFrame.

>>> import functools
>>> @functools.lru_cache
... def scale_frame(a, b):
...     return a * b
...
>>> import pandas as pd
>>> df = pd.DataFrame(np.arange(20).reshape(5, 4))
>>> scale_frame(df, 2)
Traceback (most recent call last):
  File "<console>", line 1, in <module>
TypeError: unhashable type: 'DataFrame'


StaticFrame is an alternative DataFrame library that offers efficient solutions to this and related problems, both for in-memory and disk based memoization.


All Hashes Are not Created Equal
................................................

Before demonstrating effective DataFrame memoization with StaticFrame, it is important to clarify the sometimes conflicting meanings of "hash", particularly in the context of Python.

A hashing function converts a variable-sized value into a smaller, fixed-sized value. The results of hashing different inputs might be the same: this is called a collision. For some applications, hash collisions are acceptable; for others, they are a significant problem. Cryptographic hashes aim to eliminate collisions.

In Python, the the built-in ``hash()`` function converts hashable objects into an integer. Arbitrary types can provide support by implementing ``__hash__()``. Many Python users are surprised to learn that the results of ``hash()`` are not collision resistant:

>>> hash('')
0
>>> hash(0)
0
>>> hash(False)
0

Python dictionaries use ``hash()`` to transform dictionary keys into storage positions in a low-level C array. Collisions are expected, and if found, are resolved in look-up routines with equality comparisons (using the magic method ``__eq__()``). Thus, for an arbitrary type to be hashable, it needs to implement both ``__hash__()`` and ``__eq__()``.

Cryptographic hashing functions are unlike ``hash()``: they are designed to avoid collisions. Python exposes a collection of cryptographic hashing functions in the ``hashlib`` library. These functions generally consume byte data and return a string of fixed size.

>>> hashlib.sha256(b'').hexdigest()
'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'
>>> hashlib.sha256(b'0').hexdigest()
'5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9'
>>> hashlib.sha256(b'False').hexdigest()
'60a33e6cf5151f2d52eddae9685cfa270426aa89d8dbc7dfb854606f1d1a40fe'

In Python, dictionary keys must be hashable. Most in-memory memoization implementations (such as ``functools.lru_cache()``), store function results in dictionaries keyed by arguments. This is why function arguments must be hashasble.

For disk-based memoization and other caching applications, deriving a unique string from function arguments is necessary. Here, a cryptographic hashing algorithm is necessary as collisions are not resolved by any additional equality checks.


In-Memory Memoization of DataFrame Processing Functions
.................................................................

As in-memory memoization requires hashable arguments, we need hashable DataFrames to memoize functions that take DataFrames as arguments.

StaticFrame offers ``FrameHE`` and ``SeriesHE`` for this purpose, where "HE" stands for "hash, equals," the two required implementations for hashability.

The implementation of ``FrameHE.__hash__()`` returns the ``hash()`` of the labels of the index and columns. While this will collide with any other ``FrameHE`` withe same labels but different values, using just the labels defers full data array comparisons to ``__eq__()``.

The implementation of ``FrameHE.__eq__()`` simply delegates to ``Frame.equals()``, an interface designed to always return a comparison as a single Boolean result. This contrasts with ``Frame.__eq__()``, which returns an element-wise comparison in a Boolean ``Frame``.

We can now use the ``scale_frame()`` function, defined above, with a ``FrameHE`` as an argument. The ``Frame.to_frame_he() method can be used to efficiently provide a ``FrameHE`` from a ``Frame`` or other StaticFrame container. As underlying NumPy array data is immutable, this is light-weight, no-copy operation. If coming from a Pandas DataFrame, ``FrameHE.from_pandas()`` can be used.

In the example below we create a large ``FrameHE``; we see with the IPython ``%time`` results, after being called once, subsequent calls with the same arguments are three orders of magnitude faster (from ms to µs).

>>> f = sf.FrameHE(np.arange(1_000_000).reshape(1000, 1000))
>>> %time scale_frame(f, 10)
CPU times: user 1.58 ms, sys: 4.14 ms, total: 5.72 ms
>>> %time scale_frame(f, 10)
CPU times: user 9 µs, sys: 1e+03 ns, total: 10 µs

While helpful for in-memory memoization, ``FrameHE`` and ``SeriesHE`` can also be members of sets, offering a novel approach to collecting unique containers.




Disk-Based Memoization of DataFrame Processing Functions
.................................................................




Conclusion
.................................................................




We might avoid this problem by using a cryptographic hash function to first produce a messsage digest of the DataFrame: the resulting string can serve as key in a dictionary or a file name on disk. Getting the right input into such a function is not trivial. While Pandas provides a ``pd.hash_pandas_object`` utility function possibly for this purpose, the implementation is slow (as will be shown below) and uses a bespoke digest algorithm that shows no evidence of the proven collision resistance of commonly used approaches such as SAH256.










>>> def cache(f):
...     store = {}
...     def wrapped(*args):
...         if args not in store:
...             store[args] = f(*args)
...         return store[args]
...     return wrapped
...


https://stackoverflow.com/questions/49883236/how-to-generate-a-hash-or-checksum-value-on-python-dataframe-created-from-a-fix


https://stackoverflow.com/questions/47707528/save-repeated-calculations-in-python-pandas