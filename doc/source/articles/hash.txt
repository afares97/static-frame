



DataFrame Memoization: Using Hashable DataFrames and Cryptographic Message Digests to Optimize Performance of Repeated Calculations

Improving the Performance of Python DataFrame Operations with Memoization:
How StaticFrame Permits Hashing DataFrames in Dictionaries and Deriving Cryptographic Message Digests


Improving the Performance of Python DataFrame Operations with Memoization: Hashing DataFrames in Dictionaries and Creating Message Digests

Hashing DataFrames for Usage in Dictionaries, Memoization, and Caching

Memoizing DataFrame Operations: Hashing DataFrames in Dictionaries and Creating Caches


--

A well-known technique for improving the run-time performance of a software system (in Python or any language) is function memoization. Memoization is a type of caching applied to a single function. If a function is being called multiple times with the same arguments, we can avoid repeating the calculation by storing the results in a mapping (or on disk), keyed (or named) by the arguments: upon subsequent calls, we can look for the arguments in the mapping and, if found, avoid repeating the computation by simply returning the stored result.

This opportunity does not come without tradeoffs. Memoization reduces time at the cost of space: previously calculated results must be stored either in memory or on disk. Additionally, the function memoized must be pure: the output must be determined exclusively by its inputs. Finally, there are restrictions on the types of function arguments. For in-memory memoization, where results are stored in a mapping, arguments must be hashable and immutable. For disk-based memoization, where results are stored in a file, arguments must be reducible to a unique file name; a message digest derived from a cryptographic hash function is optimal for this purpose.

Another challenge of memoization is cache invalidation: to avoid excessive cache growth, caches must be dropped. The Python standard library provides an in-memory solution with the ``functools.lru_cache()`` decorator. This decorator implements memoization with a "least recently used" cache invalidation strategy: after reaching a maximum count, caches that have least-recently been used are dropped.

For Python programmers using Pandas DataFrames as function arguments, there are further challenges. As mutable containers, Pandas ``DataFrame`` and ``Series`` are not hashable. The ``functools.lru_cache()`` will fail if an argument is a Pandas DataFrame.

>>> import functools
>>> @functools.lru_cache
... def cube(v):
...     return v ** 3
...
>>> import pandas as pd
>>> df = pd.DataFrame(np.arange(1_000_000).reshape(1000, 1000))
>>> cube(df)
Traceback (most recent call last):
  File "<console>", line 1, in <module>
TypeError: unhashable type: 'DataFrame'


StaticFrame is an alternative DataFrame library that offers efficient solutions to this problems, both for in-memory and disk-based memoization.


All Hashes Are not Created Equal
................................................

Before demonstrating effective DataFrame memoization with StaticFrame, it is important to distinguish different types of hash functions.

A hashing function converts a variable-sized value into a smaller, (generally) fixed-sized value. The results of hashing different inputs might be the same: this is called a hash collision. For some applications, hash collisions are acceptable; for others, they are a significant problem. Cryptographic hashes aim to eliminate collisions.

In Python, the built-in ``hash()`` function converts hashable objects into an integer. Arbitrary types can provide support by implementing the magic method ``__hash__()``. Importantly, the results of ``hash()`` are not collision resistant:

>>> hash('')
0
>>> hash(0)
0
>>> hash(False)
0

Python dictionaries use ``hash()`` to transform dictionary keys into storage positions in a low-level C array. Collisions are expected, and if found, are resolved with equality comparisons (using ``__eq__()``). Thus, for an arbitrary type to be hashable, it needs to implement both ``__hash__()`` and ``__eq__()``.

Cryptographic hashing functions are unlike ``hash()``: they are designed to avoid collisions. Python implements a collection of cryptographic hashing functions in the ``hashlib`` library. These functions consume byte data and return , with the ``hexdigest()`` method, a message digest as a unique string of fixed size.

>>> import hashlib
>>> hashlib.sha256(b'').hexdigest()
'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'
>>> hashlib.sha256(b'0').hexdigest()
'5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9'
>>> hashlib.sha256(b'False').hexdigest()
'60a33e6cf5151f2d52eddae9685cfa270426aa89d8dbc7dfb854606f1d1a40fe'



In-Memory Memoization of DataFrame Processing Functions
.................................................................

To memoize functions that take DataFrames as arguments, an immutable, hashable DataFrame is required. While the StaticFrame ``Frame`` is immutable, it is not hashable. StaticFrame offers the ``FrameHE`` for this purpose, where "HE" stands for "hash, equals," the two required implementations for Python hashability.

The implementation of ``FrameHE.__hash__()`` returns the ``hash()`` of the labels of the index and columns. While this will collide with any other ``FrameHE`` with same labels but different values, using just the labels defers the more expensive full-value comparison to ``__eq__()``.

The implementation of ``FrameHE.__eq__()`` simply delegates to ``Frame.equals()``, an interface designed to always return a full-value comparison as a single Boolean result. This contrasts with ``Frame.__eq__()``, which returns an element-wise comparison in a Boolean ``Frame``.

We can now use the ``cube()`` function, decorated above with the ``functools.lru_cache()`` decorator, with a ``FrameHE`` as an argument. Note that the ``Frame.to_frame_he()`` method can be used to efficiently create a ``FrameHE`` from other StaticFrame containers. As underlying NumPy array data is always immutable, this is light-weight, no-copy operation. If coming from a Pandas DataFrame, ``FrameHE.from_pandas()`` can be used.

In the example below we create a large ``FrameHE``. The IPython ``%time`` utility shows that, after being called once, subsequent calls with the same argument are three orders of magnitude faster (from ms to µs).

>>> f = sf.FrameHE(np.arange(1_000_000).reshape(1000, 1000))
>>> %time cube(f)
CPU times: user 8.24 ms, sys: 99 µs, total: 8.34 ms
>>> %time cube(f)
CPU times: user 5 µs, sys: 4 µs, total: 9 µs

While helpful for in-memory memoization, ``FrameHE`` can also be members of sets, offering a novel approach to collecting unique containers.


Disk-Based Memoization of DataFrame Processing Functions
.................................................................

While in-memory memoization offers optimal performance, the caches consume system memory and do not persist beyond the life of the process. If function results are large, or caches should persist beyond the life the process, disk-based memoization is an alternative.

In this scenario, mutability and hashability of arguments is irrelevant. Instead, cached results can be retreived from a file with a name derived from the function arguments. Using a cryptographic hash to derive a message digest is ideal for this purpose.

As cryptographic hash functions take bytes as input, inputting a container as complex as a ``Frame`` is not trivial. A naive approach might serialize the ``Frame`` as JSON (or some other string representation), which can then be converted to bytes. This is inefficient, as underlying NumPy array data, while already stored in bytes, must be converted to strings. This also may be incorrect, as JSON does not support the full range of NumPy types.

StaticFrame implements an efficient interface to provide input to nearly all cryptographic hash functions in the standard library ``hashlib`` module. An example is given below.

>>> f.via_hashlib(include_name=False).sha256().hexdigest()
'b931bd5662bb75949404f3735acf652cf177c5236e9d20342851417325dd026c'

First, ``via_hashlib()`` is called, providing options to determine which container components should be included in the hash. As the default container ``name`` attribute, ``None``, is not byte encodable, it is excluded. Second, a hash function is called, returning an instance from the ``hashlib`` module loaded with the appropriate input. Third, the ``hexdigest()`` method is called to return the message digest as a string. The full range of ``hashlib`` instance methods are available.

To create the input to the cryptographic hashing function, StaticFrame concatenates all underlying byte data, as well as optional container metadata. This same byte representation is available with a ``to_bytes()`` method. If necessary, this data can be combined with other byte data to create a hash digest based on multiple components.

>>> len(f.via_hashlib(include_name=False).to_bytes())
8016017

This approach to creating a hash digest with StaticFrame is generally more efficient than two common approaches with Pandas. Pandas offers a utilty function, ``pd.hash_pandas_object()``, to derive per-column integer hashes. Not only is this approach slower than StaticFrame (as shown below), it uses a bespoke digest algorithm that makes no claim to cryptographic collision resistance. Another approach is to provide a ``hashlib`` function a JSON representation of the entire DataFrame. While this may be more collision resistant than ``pd.hash_pandas_object()``, it is slower. The following char summarizes performance characteristc of these two approaches compared to StaticFrame's ``via_hashlib``: StaticFrame out-performs Pandas in all scenarios except one.

Provided a means to convert a DataFrame into a cryptographic hash digest, implementing disk-based caching is straight forward. The decorator below implements disk-based memoization for the narrow case of a function that takes and returns a single ``Frame``. Below, caches are stored in ``/tmp``; depending on operating system and other considerations, an alternative directory might be more appropriate.


>>> def disk_cache(func):
...     def wrapped(arg):
...         fn = func.__name__ + arg.via_hashlib(include_name=False).sha256().hexdigest() + '.npz'
...         fp = Path('/tmp') / fn
...         if not fp.exists():
...             func(arg).to_npz(fp)
...         return sf.Frame.from_npz(fp)
...     return wrapped


This decorator can be used on a function that iterates over windows of ten rows, sums the columns, and then concatenates the result into a single ``Frame``.

>>> @disk_cache
... def windowed_sum(v):
...     return sf.Frame.from_concat(v.iter_window_items(size=10).apply_iter(lambda l, f: f.sum().rename(l)))


After first usage, performance is reduced to less than twenty percent of the original run time. While loading a disk-based cache is slower than retrieving an in-memory cache, the benefit for repeated calculation is significant

>>> %time windowed_sum(f)
CPU times: user 596 ms, sys: 15.6 ms, total: 612 ms
>>> %time windowed_sum(f)
CPU times: user 77.3 ms, sys: 24.4 ms, total: 102 ms



Conclusion
.................................................................

If pure functions are called multiple times with same arguments, memoization can vastly improve performance. While functions that input and output DataFrames pose special consideration, StaticFrame offers powerful tools to implement both in-memory and disk-based memoization. Great care must be taken to ensure that caches are invalidated and collisions are avoided, as such errors are silent and difficult to debug. Even so, great performance benefits await when repeated work can be eliminated.





------------------------
notes


In Python, dictionary keys must be hashable. Most in-memory memoization implementations (such as ``functools.lru_cache()``), store function results in dictionaries keyed by arguments. This is why function arguments must be hashasble.

For disk-based memoization and other caching applications, deriving a unique string from function arguments is necessary. Here, a cryptographic hashing algorithm is necessary as collisions are not resolved by any additional equality checks.

We might avoid this problem by using a cryptographic hash function to first produce a messsage digest of the DataFrame: the resulting string can serve as key in a dictionary or a file name on disk. Getting the right input into such a function is not trivial.



>>> def cache(func):
...     def wrapped(arg):
            fn = arg.via_hashlib(include_name=False).sha256().hexdigest() + '.npz'
...         fp = Path('/tmp') / fn
...         if not fp.exists():
...             func(arg).to_npz(fp)
...         return sf.Frame.from_npz(fp)
...     return wrapped


https://stackoverflow.com/questions/49883236/how-to-generate-a-hash-or-checksum-value-on-python-dataframe-created-from-a-fix


https://stackoverflow.com/questions/47707528/save-repeated-calculations-in-python-pandas