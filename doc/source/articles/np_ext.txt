


Out-Performing NumPy is Hard: When and How to Try with Your Own C-Extensions

Writing C-Extensions to Extend Numpy

Extending NumPy with C-Extensions

Out-Performing NumPy is Hard: When a C-Extension Might Deliver Better Performance

Out-Performing NumPy is Hard: Approaches to Writing C-Extensions



While it is well-known that C-extensions can augment Python programs with compiled, high-performance routines, writing C-extensions that extend NumPy are different. Most NumPy functions already fall-back on highly optimized C routines.

Writing C-extensions that can out-perform NumPy is challenging. This presentation will cover the basics of writing C-extensions that process or create NumPy arrays. Project setup to compile and link against NumPy will be reviewed, key functions of the NumPy C-API will be introduced, and an example implementation of a simple array utility will be demonstrated.



Outline

Compiling, Linking to NumPy in setup.py, pyproject.toml

The Python C API and the NumPy C API
    Similar Naming conventions
    PyObject v. PyArrayObject pointers
    Reference stealing of PyArray_Descr arguments

Common Operations with NumPy C API
    Creating a PyArray_Descr
    Creating a PyArrayObject
    Iterating through an Array

Anti-Patterns for NumPy C-Extensions
    Ignoring early performance comparisons
    Reimplementing what NumPy has already done
    Calling on Vector operations
    Interactions with Python objects

Opportunities for Performance Advantage
    Bulk of operations happen in C
    Operations on C arrays

Bridging C arrays and NumPy arrays
    PyArray_DATA
    Expectations of Contiguous Data

Example: finding the the first or last True Boolean
    Problems with `np.nonzero` and `np.argmax`
    Enforcing dtype contiguity requirements
    Implementing a 1D solution
    Implementing a 2D solution
    performance comparisons







