


Out-Performing NumPy is Hard: When and How to Try with Your Own C-Extensions

Writing C-Extensions to Extend Numpy

Extending NumPy with C-Extensions

Out-Performing NumPy is Hard: When a C-Extension Might Deliver Better Performance

Out-Performing NumPy is Hard: Approaches to Writing C-Extensions



While it is well-known that C-extensions can augment Python programs with compiled, high-performance routines, writing C-extensions that extend NumPy are different. Most NumPy functions already fall-back on highly optimized C routines, some of which take advantage of esoteric, low-level processor optimizations.

Writing C-extensions that can out-perform NumPy is challenging. This presentation will provide guidelines to help determine if a routine, implemented as a C-extension, might outperform NumPy.

The basics of writing C-extensions that process or create NumPy arrays will be prestented; project setup to compile and link against NumPy will be reviewed; key functions of the NumPy C-API will be introduced; and an example implementation of a simple array utility that (mostly) out-performs NumPy will be demonstrated.



Outline

Python Projects that Compile and Linking to NumPy
    setup.py
    pyproject.toml

The Python C API and the NumPy C API
    Common naming conventions
    PyObject v. PyArrayObject pointers
    Reference stealing of PyArray_Descr arguments

Common Operations with NumPy C API
    Creating ``PyArray_Descr``
    Creating ``PyArrayObject``
    Iterating through an array
    Writing to an array

Anti-Patterns for NumPy C-Extensions
    Ignoring early performance comparisons
    Reimplementing what NumPy has already done
    Calling on Vector operations
    Interactions with Python objects

Opportunities for Performance Advantage
    Bulk of operations happen in C
    Operations on C arrays
    Opportunities to simplify what NumPy is doing

Bridging C arrays and NumPy arrays
    ``PyArray_DATA``
    Expectations of Contiguous Data

Example: finding the the first or last True Boolean
    Built-in NumPy alternatives
        Full-array comparison
        `np.nonzero`
        `np.argmax`
    Enforcing dimensionality, dtype, and contiguity requirements
    Implementing a 1D solution
    Implementing a 2D solution
    Performance comparisons









From numpy, item_selection.c
For counting, we see usage of NPY_SIMD
        if (is_bool) {
            /*
             * use fast memchr variant for sparse data, see gh-4370
             * the fast bool count is followed by this sparse path is faster
             * than combining the two loops, even for larger arrays
             */
            if (((double)nonzero_count / count) <= 0.1) {
                npy_intp subsize;
                npy_intp j = 0;
                while (1) {
                    npy_memchr(data + j * stride, 0, stride, count - j,
                               &subsize, 1);
                    j += subsize;
                    if (j >= count) {
                        break;
                    }
                    *multi_index++ = j++;
                }
            }
            /*
             * Fallback to a branchless strategy to avoid branch misprediction
             * stalls that are very expensive on most modern processors.
             */
            else {
                npy_intp *multi_index_end = multi_index + nonzero_count;
                npy_intp j = 0;

                /* Manually unroll for GCC and maybe other compilers */
                while (multi_index + 4 < multi_index_end) {
                    *multi_index = j;
                    multi_index += data[0] != 0;
                    *multi_index = j + 1;
                    multi_index += data[stride] != 0;
                    *multi_index = j + 2;
                    multi_index += data[stride * 2] != 0;
                    *multi_index = j + 3;
                    multi_index += data[stride * 3] != 0;
                    data += stride * 4;
                    j += 4;
                }

                while (multi_index < multi_index_end) {
                    *multi_index = j;
                    multi_index += *data != 0;
                    data += stride;
                    ++j;
                }
            }
        }