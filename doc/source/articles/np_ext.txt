


Out-Performing NumPy is Hard: When and How to Try with Your Own C-Extensions

Writing C-Extensions to Extend Numpy

Extending NumPy with C-Extensions

Out-Performing NumPy is Hard: When a C-Extension Might Deliver Better Performance

Out-Performing NumPy is Hard: Approaches to Writing C-Extensions


While it is well known that C-extensions can improve the performance of Python programs, writing C-extensions that extend NumPy are different. Most NumPy functions already call highly optimized C routines, some of which take advantage of somewhat esoteric, low-level processor optimizations.

Writing C-extensions that out-perform NumPy is challenging: in most cases, just writing Python that calls NumPy is optimal. But for routines of sufficiently narrow scope, there are opportunities. This presentation will suggest principles to help determine if a routine, implemented as a C-extension, might outperform NumPy.

The basics of writing C-extensions that process or create NumPy arrays will be presented; project setup will be reviewed; key functions of the NumPy C-API will be introduced; and an example implementation of a simple array utility that (mostly) out-performs NumPy will be demonstrated.



Outline

A Python Project that Compiles C-extensions and Links to NumPy
    setup.py
    pyproject.toml

The Python C API and the NumPy C API
    Common naming conventions
    PyObject v. PyArrayObject pointers
    Reference counting
    Reference stealing of PyArray_Descr arguments

Common Operations with the NumPy C API
    Creating ``PyArray_Descr``
    Creating ``PyArrayObject``
        PyArray_Empty
        PyArray_Zeros
    Getting basic array characteristics
        dtype
        Shape
        Dimensionality
        Data flags
            C / Fortran ordering
            Contiguity
    Reading / writing values from / to an array
        PyArray_GETITEM
        PyArray_GetPtr
    Array data as a C array
        When you can use PyArray_DATA
        When you need NpyIter


Anti-Patterns for NumPy C-Extensions
    Ignoring early performance comparisons
    Reimplementing what NumPy has already done
    Calling on vector operations
    Creating arrays with Python objects

Opportunities for Performance Advantage
    Bulk of operations happen in C
    NumPy arrays as C arrays
        Using PyArray_DATA for reading and writing
    Can simplify what NumPy is doing
        Limited dimensionality
        Supporting on a few types
        Requiring contiguity


Example C-extension Implementation: first_true_1d()
    Finding the first or last True Boolean
    Built-in NumPy alternatives do not have a quick exit
        Full-array comparison to True
        `np.nonzero()`
    Built-in `np.argmax()` does not distinguish case of no True found

    Opportunity to simplify what NumPy is Doing
        Can limit supported dimensions
        Can limit dtypes
        Can require contiguity
    Opportunity to opperate on C array
        Can quickly scan C array of Booleans
        No Python objects or reference counting needed

    Implementing a 1D solution
    Implementing a 2D solution

Performance Comparisons of first_true_1d
    Can outperform `np.nonzero()` when there are many Trues
    When few Trues exist, ``np.nonzero()`` still outperforms
        Usage of loop unrolling
        Usage of Single Instruction Multiple Data (SIMD) routines

Conclusion
    Outperforming NumPy, even in pure C, is hard
    There exist opportunities by finding narrow cases
    Performance test early and often


----------------------


From numpy, item_selection.c
For counting, we see usage of NPY_SIMD
        if (is_bool) {
            /*
             * use fast memchr variant for sparse data, see gh-4370
             * the fast bool count is followed by this sparse path is faster
             * than combining the two loops, even for larger arrays
             */
            if (((double)nonzero_count / count) <= 0.1) {
                npy_intp subsize;
                npy_intp j = 0;
                while (1) {
                    npy_memchr(data + j * stride, 0, stride, count - j,
                               &subsize, 1);
                    j += subsize;
                    if (j >= count) {
                        break;
                    }
                    *multi_index++ = j++;
                }
            }
            /*
             * Fallback to a branchless strategy to avoid branch misprediction
             * stalls that are very expensive on most modern processors.
             */
            else {
                npy_intp *multi_index_end = multi_index + nonzero_count;
                npy_intp j = 0;

                /* Manually unroll for GCC and maybe other compilers */
                while (multi_index + 4 < multi_index_end) {
                    *multi_index = j;
                    multi_index += data[0] != 0;
                    *multi_index = j + 1;
                    multi_index += data[stride] != 0;
                    *multi_index = j + 2;
                    multi_index += data[stride * 2] != 0;
                    *multi_index = j + 3;
                    multi_index += data[stride * 3] != 0;
                    data += stride * 4;
                    j += 4;
                }

                while (multi_index < multi_index_end) {
                    *multi_index = j;
                    multi_index += *data != 0;
                    data += stride;
                    ++j;
                }
            }
        }