




One `fill_value` Is Not Enough: Reindexing DataFrames with Hetergenous Types

One `fill_value` Is Not Enough: Preserving Columnar Types when Reindexing DataFrames

How to Reindex Dataframes without Degrading your Types



When working with DataFrames, reindexing is common. When we reindex, we conform an old index (and its associated values) into a new index, potentially reordering, removing, or expanding the rows and columns in a DataFrame. When a reindex expands rows or columns, new values need to be supplied to fill the newly created rows or columns. In Pandas, only a single value, via the ``fill_value`` parameter, is permitted. If that ``fill_value`` is of a type not compatible with the column's type, the column will be re-cast into different, likely undesirable (object) type.

For example, given a DataFrame with a column each of object, integer, and Boolean, reindexing the index, by default, injects `NaN`s, a float type that causes the integer column to be converted to float and the Boolean column to be converted to object:

>>> df = pd.DataFrame.from_records((('a', 1, True), ('b', 2, False)), columns=tuple('xyz'))
>>> df.dtypes
x    object
y     int64
z      bool
dtype: object

>>> df.reindex((1, 0, 2))
     x    y      z
1    b  2.0  False
0    a  1.0   True
2  NaN  NaN    NaN
>>> df.reindex((1, 0, 2)).dtypes
x     object
y    float64
z     object
dtype: object


In most cases such type degradation is detrimental, as the intended columnar type has changed as a result of the reindexing (perhaps without the user noticing). Further, when going to object types, the performance of subsequent operations might be significantly degraded. In Pandas, there is no way to avoid this problem.

In StaticFrame, alternative fill value representations can be provided to preserve columnar types in reindexing, shifting, and filling missing values. For operations on hetergenously typed columnar data, one fill value is simply not enough.

StaticFrame supports providing ``fill_value`` as a single element, as a row-length list of values, as a mapping by column label, or as a ``FillValueAuto``, an object to define dtype kind to value mappings. Each of these will be demonstrated in the context of reindexing.

We can create the same DataFrame in StaticFrame and reindex it with a single fill value, ``np.nan``. This results in the same columnar types as Pandas. Notice that StaticFrame, by default, shows the dtype for each column, making type changes easily visible.

>>> f = sf.Frame.from_records((('a', 1, True), ('b', 2, False)), columns=tuple('xyz'))
>>> f
<Frame>
<Index> x     y       z      <<U1>
<Index>
0       a     1       True
1       b     2       False
<int64> <<U1> <int64> <bool>

>>> f.reindex((1, 0, 2), fill_value=np.nan)
<Frame>
<Index> x        y         z        <<U1>
<Index>
1       b        2.0       False
0       a        1.0       True
2       nan      nan       nan
<int64> <object> <float64> <object>


Beyond a single element, a fill value can provide a list of fill values per column:

>>> f.reindex((1, 0, 2), fill_value=['', 0, False])
<Frame>
<Index> x     y       z      <<U1>
<Index>
1       b     2       False
0       a     1       True
2             0       False
<int64> <<U1> <int64> <bool>


A dictionary can be used to provide a mapping of column label to fill value. If label is not provided, the default (``np.nan``) will be provided.

>>> f.reindex((1, 0, 2), fill_value={'z':False, 'x':''})
<Frame>
<Index> x     y         z      <<U1>
<Index>
1       b     2.0       False
0       a     1.0       True
2             nan       False
<int64> <<U1> <float64> <bool>


The previous examples all require an explicit value per column, providing maximum specificity. In many cases (and in particular for larger DataFrames), a more general specification is appropriate.

Specifying a fill vlaue per dtype kind can be used to avoid type coercions while not requiring a specifcation per column. NumPy dtypes have a "kind" independent of dtype "size": for example, int8, int16, int32, and int64 dtypes all have kind "i". There are eleven dtype kinds summarized in the table below:

+-----+------------+
|Kind |Example name|
+=====+============+
|b    |bool        |
+-----+------------+
|i    |int64       |
+-----+------------+
|u    |uint64      |
+-----+------------+
|f    |float64     |
+-----+------------+
|c    |complex128  |
+-----+------------+
|m    |timedelta64 |
+-----+------------+
|M    |datetime64  |
+-----+------------+
|O    |object      |
+-----+------------+
|S    |bytes       |
+-----+------------+
|U    |str         |
+-----+------------+
|V    |void        |
+-----+------------+



The fill value `FillValueAuto`, used as a class, will provide tyep-coercion-free defaults for all kinds. If a different mapping is desired, a ``FillValueAuto`` instance can be created, specifying a value per kind.

fill value auto examples


# show shift, fillna examples


# show via_fill_value
















==

>>> df = pd.DataFrame.from_records((('a', 1, True), ('b', 2, False)), columns=tuple('xyz'))
>>> df.reindex((1, 0, 2))
     x    y      z
1    b  2.0  False
0    a  1.0   True
2  NaN  NaN    NaN
>>> df.reindex((1, 0, 2)).dtypes
x     object
y    float64
z     object
dtype: object



Reindexing can be done explicitly, when we call ``reindex()``, or implicitly, such as when peforming binary operations with ``Series`` as operands.



>>> df = pd.DataFrame.from_records((('a', 1, True), ('b', 2, False)), columns=tuple('xyz'))


>>> df.reindex((1, 0, 2), fill_value=[-1, -2, -3])
fails on 1.4.2

>>> df.reindex((1, 0, 2), fill_value={'x':-1, 'y':-2, 'z':-3})
fails on 1.4.2

# multiple fill values are only support with the fillna interface

>>> df2.fillna({'x':-1, 'y':-2, 'z':-3})
    x    y      z
1   b  2.0  False
0   a  1.0   True
2  -1 -2.0     -3




>>> types = [np.dtype(bool), np.dtype(int), np.dtype(np.uint), np.dtype(float), np.dtype(complex), np.dtype(np.timedelta64), np.dtype(np.datetime64), np.dtype(object), np.dtype(bytes), np.dtype(str), np.dtype(np.void)]

>>> print(sf.Frame.from_fields(([t.kind for t in types], [t.name for t in types]), columns=('Kind', 'Example name')).to_rst(sf.DisplayConfig(include_index=False, type_show=False)))

