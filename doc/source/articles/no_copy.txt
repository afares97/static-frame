


No-Copy DataFrame Operations: Performance Advantages of an Immutable NumPy Data Model



We will use the term "no-copy" to describe an operation on a container (a DataFrame) where a new, light-weight instance is created, but underlying data is not copied (it is referenced). Sometimes the same notion is convayed by the term "shallow copy".

NumPy makes no-copy operations the primary way of working with array data. When you slice a NumPy array you get a new array that shares the data from which it was sliced. This is a no-copy operation. The benefit is the extraordinary performance gains of not having to copy already-allocated contiguous byte data, but instead just storing offsets and strides into that data.

We can look at an array's `flags` to see information about its memory usage, and we can look at the `base` attribute to get a reference to the array that actually holds the byte data. In the example below, we create an array, take a slice, and look at the flags of the slice. We see that, for the slice, OWNDATA is False, and that the ``base`` of the slice has the same object ``id()`` as the array it came from.

>>> a1 = np.arange(12)
>>> a1
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

>>> a2 = a1[:6]
>>> a2.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : True
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False

>>> id(a1), id(a2.base)
(140506320732848, 140506320732848)


We might think of these derived arrays as "views" of the original array. We can take no-copy views of arrays under certain conditions: if we are re-shapping an array; if we are tranposing an array; and if we are slicing an array.

For example, we can reshape the initial array into a 2D array and observe that OWNDATA is False; it still references the original array's data.

>>> a3 = a1.reshape(3,4)
>>> a3
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> a3.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False

>>> id(a3.base), id(a1)
(140506320732848, 140506320732848)

Both horizontal and vertical slices of this 2D array similarly result in arrays that simply reference the original array's data. Again, OWNDATA is False.

>>> a4 = a3[:, 2]
>>> a4
array([ 2,  6, 10])

>>> a4.flags
  C_CONTIGUOUS : False
  F_CONTIGUOUS : False
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False

>>> id(a1), id(a4.base)
(140506320732848, 140506320732848)

While the performance benefits of creating light-weight wrappers around shared memory buffers are clear, there is a risk: mutating any one of those arrays in-palce will mutate all of them. For example, assigning -1 into our most-derived array is reflected in every array, the original and every view.

>>> a4[0] = -1
>>> a4
array([-1,  6, 10])
>>> a3
array([[ 0,  1, -1,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> a2
array([ 0,  1, -1,  3,  4,  5])
>>> a1
array([ 0,  1, -1,  3,  4,  5,  6,  7,  8,  9, 10, 11])


It is likely a good intuition if side-effects like this concern you. There are countless ways passing around views of shared memory to clients that can mutate that data can lead to serious flaws. There are two solutions to this problem.

One option is for the caller to make explicit "defensive" copies every time a new array is created. This removes the performance advantage of shared memory but ensures that mutating an array does not lead to unexpected side effects.

Another option, requiring no sacrifice in performance, is to make the array immutable. By doing so, you can freely share views of arrays without conern of a client mutating a derived array and causing unexpected side effects. NumPy makes this easy by setting the ``writeable`` flag on the ``flags`` interface. Note that now, when viewing ``flags``, we see WRITEABLE is False.

>>> a1.flags.writeable = False
>>> a1.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : True
  OWNDATA : True
  WRITEABLE : False
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False

Attempting to mutate this array will result in an exception.

>>> a1[0] = -1
Traceback (most recent call last):
  File "<console>", line 1, in <module>
ValueError: assignment destination is read-only


The best performance is possible, with no risk of side-effects, by embraching NumPy views with the protection of making those arrays immutable.

The performance overhead of defensive copying is proportional to the size of the data but will generally be orders of mangntiude slower than sharing views. For example, the difference between slicing an array of 100,000 and slicing then copying the same array is two orders of magnitude.

>>> data = np.arange(100_000)
>>> %timeit data[:50_000]
237 ns ± 6.22 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)

>>> %timeit data[:50_000].copy()
13.7 µs ± 198 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)


This insight, that an immutable-array-based data model offers the best peformance with the minmum risk, was foundational to the creation of the StaticFrame DataFrame library. As StaticFrame (like Pandas) manages data stored in NumPy arrays, embracing the usage of data views (without defensive copies) offers significant performance advantages. Without an immutable data model, Pandas has to make defensive copies. The performance cost is orders of magnitude.

StaticFrame is not always faster than Pandas: Pandas has very performant operations for joins and related transformations. Buy when leveraging array views, StaticFrame can be a lot faster. To demonstrate StaticFrame's performance advantage we will use the FrameFixtures library to create two DataFrames of 10,000 rows by 1,000 columns of heterogenous types. For both we can convert the StaticFrame ``Frame`` to a Pandas ``DataFraem``.

>>> f1 = ff.parse('s(10_000,1000)|v(int,int,str,float)')
>>> df1 = f1.to_pandas()
>>> f2 = ff.parse('s(10_000,1000)|v(int,bool,bool,float)')
>>> df2 = f2.to_pandas()


Perhaps the simplest example is renaming an axis (or index). With Pandas, all underlying data is defensively copied. With StaticFrame, all underlying data is re-used, only lightweight outer containers have to be created. StaticFrame is three orders of magnitude faster.

>>> %timeit df.rename_axis('foo')
72 ms ± 775 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
>>> %timeit f1.rename(index='foo')
34.7 µs ± 99 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)

Given a DataFrame, a common move is to make a column into the index. When Pandas does this, it has to copy the column data to the index, as well as copy all the underlying data. StaticFrame can re-use view of the column in the Index, as well as re-use all of the underlying data. StaticFrame is two orders of magnitude faster.


>>> %timeit df.set_index(0, drop=False)
71.3 ms ± 384 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
>>> %timeit f1.set_index(0)
927 µs ± 2.94 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)


Another comon move is extracting a subset of columns from a DataFrame. StaticFrame can do this an order of magnitude faster than Pandas. Again, the returned DataFrame simply has views to the columns in from the original DataFrame: this is a no-copy operation.


>>> %timeit df[[3, 300, 828]]
332 µs ± 9.22 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
>>> %timeit f1[[3, 300, 828]]
31.6 µs ± 225 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)


It is common to combine two DataFrames. If they have the same index and we concatenate them horizontally, StaticFrame can re-use all the underlying data without copying. Pandas has to copy all underlying data, resulting in process that is two orders of magnitude slower.

>>> %timeit pd.concat((df1, df2), axis=1)
112 ms ± 354 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
>>> %timeit sf.Frame.from_concat((f1, f2), axis=1, columns=sf.IndexAutoFactory)
1.09 ms ± 18.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)


NumPy was designed to take advantage of sharing views of data. Because Pandas permits in-place mutability, it cannot make optimal use of these views, and cannot offer as many no-copy operations as StaticFrame. While StaticFrame is not always faster, it as this fundamental advantage while illeminating side-effect risk.




>>> a1 = np.arange(12)
>>> a2 = a1[:6]
>>> a3 = a1.reshape(3,4)
>>> a4 = a3[:, 2]
>>> a4[0] = -1